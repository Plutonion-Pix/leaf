/*
TODO :
1. Let choose between CPU vectors and GPU vectors.

*/

#include standar
extern C {
#include <math.h>
}

#ifndefdefine VECTOR_PRECISION float
#define FVEC VECTOR_PRECISION

class vec2 {
	FVEC x, y
	vec2() : x(0), y(0)
	vec2(FVEC x) : x(x), y(0)
	vec2(FVEC x, FVEC y) : x(x), y(y)
	vec2(vec2 v) : x(v.x), y(v.y)

	s_inline vec2 operator+(vec2 other) {
		return vec2(this->x + other.x, this->y + other.y)
	}

	s_inline vec2 operator-(vec2 other) {
		return vec2(this->x - other.x, this->y - other.y)
	}
	
	s_inline vec2 operator*(FVEC other) {
		return vec2(this->x * other, this->y * other)
	}
	
	s_inline vec2 operator/(FVEC other) {
		return vec2(this->x / other, this->y / other)
	}

	/////////////////////////////////

	s_inline vec2 operator+=(vec2 other) {
		*this->x += other.x
		*this->y += other.y
		return *this
	}

	s_inline vec2 operator-=(vec2 other) {
		*this->x -= other.x
		*this->y -= other.y
		return *this
	}
	
	s_inline vec2 operator*=(FVEC other) {
		*this->x *= other
		*this->y *= other
		return *this
	}
	
	s_inline vec2 operator/=(FVEC other) {
		*this->x /= other
		*this->y /= other
		return *this
	}
}

class vec3 {
	FVEC x, y, z
	vec3() : x(0), y(0), z(0)
	vec3(FVEC x) : x(x), y(0), z(0)
	vec3(FVEC x, FVEC y) : x(x), y(y), z(0)
	vec3(FVEC x, FVEC y, FVEC z) : x(x), y(y), z(z)
	vec3(vec3 v) : x(v.x), y(v.y), z(v.z)
	vec3(vec2 v) : x(v.x), y(v.y), z(0)

	virtual r = x
	virtual g = y
	virtual b = z

	s_inline vec3 operator+(vec3 other) {
		return vec3(this->x + other.x, this->y + other.y, this->z + other.z)
	}

	s_inline vec3 operator-(vec3 other) {
		return vec3(this->x - other.x, this->y - other.y, this->z - other.z)
	}
	
	s_inline vec3 operator*(FVEC other) {
		return vec3(this->x * other, this->y * other, this->z * other)
	}
	
	s_inline vec3 operator/(FVEC other) {
		return vec3(this->x / other, this->y / other, this->z / other)
	}

	/////////////////////////////////

	s_inline vec3 operator+=(vec3 other) {
		*this->x += other.x
		*this->y += other.y
		*this->z += other.z
		return *this
	}

	s_inline vec3 operator-=(vec3 other) {
		*this->x -= other.x
		*this->y -= other.y
		*this->z -= other.z
		return *this
	}
	
	s_inline vec3 operator*=(FVEC other) {
		*this->x *= other
		*this->y *= other
		*this->z *= other
		return *this
	}
	
	s_inline vec3 operator/=(FVEC other) {
		*this->x /= other
		*this->y /= other
		*this->z /= other
		return *this
	}
}

class vec4 {
	FVEC x, y, w, h
	vec3() : x(0), y(0), z(0)
	vec3(FVEC x) : x(x), y(0), z(0)
	vec3(FVEC x, FVEC y) : x(x), y(y), z(0)
	vec3(FVEC x, FVEC y, FVEC z) : x(x), y(y), z(z)
	vec3(vec3 v) : x(v.x), y(v.y), z(v.z)
	vec3(vec2 v) : x(v.x), y(v.y), z(0)

	virtual .r = .x
	virtual .g = .y
	virtual .b = .w
	virtual .a = .h
	virtual .z = .w

	s_inline vec4 operator+(vec4 other) {
		return vec4(this->x + other.x, this->y + other.y, this->w + other.w, this->h + other.h)
	}

	s_inline vec4 operator-(vec4 other) {
		return vec4(this->x - other.x, this->y - other.y, this->w - other.w, this->h - other.h)
	}
	
	s_inline vec4 operator*(FVEC other) {
		return vec4(this->x * other, this->y * other, this->w * other, this->h * other)
	}
	
	s_inline vec4 operator/(FVEC other) {
		return vec4(this->x / other, this->y / other, this->w / other, this->h / other)
	}

	/////////////////////////////////

	s_inline vec4 operator+=(vec4 other) {
		*this->x += other.x
		*this->y += other.y
		*this->w += other.w
		*this->h += other.h
		return *this
	}

	s_inline vec4 operator-=(vec4 other) {
		*this->x -= other.x
		*this->y -= other.y
		*this->w -= other.w
		*this->h -= other.h
		return *this
	}
	
	s_inline vec4 operator*=(FVEC other) {
		*this->x *= other
		*this->y *= other
		*this->w *= other
		*this->h *= other
		return *this
	}
	
	s_inline vec4 operator/=(FVEC other) {
		*this->x /= other
		*this->y /= other
		*this->w /= other
		*this->h /= other
		return *this
	}
}

typedef rgb vec3
typedef rgba vec4

#funfix double acos(double x)
#funfix double asin(double x)
#funfix double atan(double x)
#funfix double atan2(double y, double x)
#funfix double cos(double x)
#funfix double cosh(double x)
#funfix double sin(double x)
#funfix double sinh(double x)
#funfix double tanh(double x)
#funfix double exp(double x)
#funfix double frexp(double x, int *exponent)
#funfix double ldexp(double x, int exponent)
#funfix double log(double x)
#funfix double log10(double x)
#funfix double modf(double x, double *integer)
#funfix double pow(double x, double y)
#funfix double sqrt(double x)
#funfix double ceil(double x)
#funfix double fabs(double x)
#funfix double floor(double x)
#funfix double fmod(double x, double y)

double abs(double x) {
	long buf = *((long*)&x)&0x7FFFFFFFFFFFFFFF
	return *((double*)&buf)
}

#funfix float acos(float x)
#funfix float asin(float x)
#funfix float atan(float x)
#funfix float atan2(float y, float x)
#funfix float cos(float x)
#funfix float cosh(float x)
#funfix float sin(float x)
#funfix float sinh(float x)
#funfix float tanh(float x)
#funfix float exp(float x)
#funfix float frexp(float x, int *exponent)
#funfix float ldexp(float x, int exponent)
#funfix float log(float x)
#funfix float log10(float x)
#funfix float modf(float x, float *integer)
#funfix float pow(float x, float y)
#funfix float sqrt(float x)
#funfix float ceil(float x)
#funfix float fabs(float x)
#funfix float floor(float x)
#funfix float fmod(float x, float y)

float abs(float x) {
	long buf = *((long*)&x)&0x7FFFFFFFFFFFFFFF
	return *((float*)&buf)
}


